# CodeDocGen â€“ Implementation & Folder Spec
...
// Cursor Spec File for CodeDocGen
// This spec should be input to Cursor AI to scaffold the full-stack application.
// Java 21 (Spring Boot - Maven) Backend + React + Material UI Frontend (Note: Earlier drafts might have mentioned Tailwind, current setup is primarily Material UI with some potential Tailwind/shadcn components based on package.json)

/*
====================================
ğŸ“˜ HIGH-LEVEL STRUCTURE
====================================
Backend: Java 21 + Spring Boot (Maven)
Frontend: React + Material UI (with potential Tailwind CSS + shadcn/ui elements)
*/

/*
====================================
ğŸ“ BACKEND PROJECT STRUCTURE (Java)
====================================
Project: codedocgen-backend
*/

codedocgen-backend/
â”œâ”€â”€ src/main/java/com/codedocgen/
â”‚   â”œâ”€â”€ CodeDocGenApplication.java
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ WebConfig.java             // Handles CORS and static resource serving for generated diagrams/docs
â”‚   â”œâ”€â”€ controller/
â”‚   â”‚   â””â”€â”€ AnalysisController.java    // Orchestrates analysis, extracts project name, handles diagram paths
â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”œâ”€â”€ RepoRequest.java
â”‚   â”‚   â”œâ”€â”€ ParsedDataResponse.java  // Includes server-relative diagram paths, project name, Spring Boot info, call flows, DAO ops, etc.
â”‚   â”‚   â””â”€â”€ MavenExecutionResult.java  // DTO for results of Maven commands
â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â”œâ”€â”€ impl/                    // Service implementations here
â”‚   â”‚   â”‚   â”œâ”€â”€ GitServiceImpl.java
â”‚   â”‚   â”‚   â”œâ”€â”€ ProjectDetectorServiceImpl.java // Detects project type, Spring Boot version
â”‚   â”‚   â”‚   â”œâ”€â”€ JavaParserServiceImpl.java // Core parsing logic, symbol resolution, class/method metadata extraction. Uses JavaSymbolSolver.
â”‚   â”‚   â”‚   â”œâ”€â”€ EndpointExtractorServiceImpl.java
â”‚   â”‚   â”‚   â”œâ”€â”€ DiagramServiceImpl.java      // Generates class, sequence, component, usecase, ERD, DB schema diagrams (SVG)
â”‚   â”‚   â”‚   â”œâ”€â”€ DocumentationServiceImpl.java // Generates project summaries, reads WSDL/XSD, Gherkin.
â”‚   â”‚   â”‚   â””â”€â”€ DaoAnalysisServiceImpl.java   // Analyzes DAO/Repository interfaces and classes for operations and DB schema details.
â”‚   â”‚   â”œâ”€â”€ GitService.java
â”‚   â”‚   â”œâ”€â”€ ProjectDetectorService.java
â”‚   â”‚   â”œâ”€â”€ JavaParserService.java
â”‚   â”‚   â”œâ”€â”€ EndpointExtractorService.java
â”‚   â”‚   â”œâ”€â”€ DiagramService.java
â”‚   â”‚   â”œâ”€â”€ DocumentationService.java
â”‚   â”‚   â””â”€â”€ DaoAnalysisService.java
â”‚   â”œâ”€â”€ parser/
â”‚   â”‚   â”œâ”€â”€ CallFlowAnalyzer.java      // Performs DFS to build call flows from method metadata.
â”‚   â”‚   â”œâ”€â”€ SoapWsdlParser.java        // (Existing, may need updates for XSD deep parsing integration if not already done)
â”‚   â”‚   â”œâ”€â”€ DaoAnalyzer.java           // Helper for DaoAnalysisServiceImpl, identifies SQL, table names from method bodies.
â”‚   â”‚   â””â”€â”€ YamlParser.java            // (Existing)
â”‚   â”œâ”€â”€ util/
â”‚   â”‚   â”œâ”€â”€ FileUtils.java
â”‚   â”‚   â””â”€â”€ PlantUMLRenderer.java      // Utility to render PlantUML source to SVG using Graphviz.
â”‚   â””â”€â”€ model/
â”‚       â”œâ”€â”€ ClassMetadata.java
â”‚       â”œâ”€â”€ MethodMetadata.java
â”‚       â”œâ”€â”€ FieldMetadata.java         // Added for field details including initializers (e.g., for annotation members)
â”‚       â”œâ”€â”€ EndpointMetadata.java
â”‚       â”œâ”€â”€ DiagramType.java
â”‚       â”œâ”€â”€ DaoOperationDetail.java  // Model for DAO operations
â”‚       â””â”€â”€ CallFlowStep.java        // (Implicitly used/generated by CallFlowAnalyzer, though maybe not a separate model class)
â”œâ”€â”€ src/main/resources/
â”‚   â””â”€â”€ application.yml              // Includes logging levels for specific classes (e.g., ClassMetadataVisitorLogger)
â”œâ”€â”€ pom.xml
â””â”€â”€ README.md

/*
====================================
ğŸ“ FRONTEND PROJECT STRUCTURE (React + Material UI / Tailwind)
====================================
Project: codedocgen-frontend
*/

codedocgen-frontend/
â”œâ”€â”€ public/
â”‚   â””â”€â”€ svg-viewer.html            // For standalone SVG viewing
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ RepoForm.js
â”‚   â”‚   â”œâ”€â”€ AnalysisDisplay.js      // Main display, uses Sidebar for navigation.
â”‚   â”‚   â”œâ”€â”€ Sidebar.js              // Main navigation component.
â”‚   â”‚   â”œâ”€â”€ EndpointTable.js        // (from .tsx)
â”‚   â”‚   â”œâ”€â”€ DiagramViewer.js        // (from .tsx) Renders diagrams from URL or direct content, handles image types.
â”‚   â”‚   â”œâ”€â”€ FeatureFileList.js      // (from .tsx)
â”‚   â”‚   â””â”€â”€ ProgressIndicator.js    // Shows loading state during analysis
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ OverviewPage.js         // Displays project summary, Spring Boot info.
â”‚   â”‚   â”œâ”€â”€ ApiSpecsPage.js         // Displays OpenAPI/SwaggerUI and detailed WSDL/XSD.
â”‚   â”‚   â”œâ”€â”€ CallFlowPage.js         // Displays sequence diagrams and raw call steps.
â”‚   â”‚   â”œâ”€â”€ DiagramsPage.js         // General diagrams page (class, component, usecase, ERD).
â”‚   â”‚   â”œâ”€â”€ DatabasePage.js         // Displays DB schema diagram and detected entities/DAO ops.
â”‚   â”‚   â”œâ”€â”€ GherkinPage.js
â”‚   â”‚   â””â”€â”€ ClassesPage.js
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ api.js                  // (from .ts) Axios API service for backend communication.
â”‚   â”œâ”€â”€ App.js                    // Main app component, handles routing, analysis results state.
â”‚   â”œâ”€â”€ index.js
â”‚   â”œâ”€â”€ index.css
â”‚   â”œâ”€â”€ constants/
â”‚   â”‚   â””â”€â”€ uiConstants.js        // For things like BACKEND_STATIC_BASE_URL
â”‚   â””â”€â”€ util/
â”‚       â””â”€â”€ diagramUtils.js       // Helpers for diagram titles, etc.
â”œâ”€â”€ .env                            // For REACT_APP_API_URL, REACT_APP_BACKEND_STATIC_URL
â”œâ”€â”€ package.json
â””â”€â”€ README.md

/*
====================================
ğŸ“˜ ITERATION ROADMAP FOR CURSOR (Reflects current state & future)
====================================
*/

1. Iteration 1: Public Git Repo Input (UI form + backend endpoint) - âœ… DONE
2. Iteration 2: Clone repo using JGit - âœ… DONE
3. Iteration 3: Detect Maven/Gradle/Raw + Spring Boot or Legacy (Spring Boot detection âœ… DONE)
4. Iteration 4: Parse all classes, methods, inheritance with **Advanced Symbol Resolution** - âœ… DONE (Major enhancements with JavaSymbolSolver)
5. Iteration 5: Extract REST and SOAP endpoints from annotations/WSDL. Categorize classes accurately. - âœ… DONE (REST, basic SOAP, improved class typing)
6. Iteration 6: Trace full call flow (controller â†’ service â†’ DAO/utils/...) - âœ… DONE (Implemented with CallFlowAnalyzer, sequence diagrams)
7. Iteration 7: Parse legacy DAO, JDBC, SQL, and table usage - âœ… DONE (Spring Data Repositories, basic SQL detection, DB schema diagrams)
8. Iteration 8: Generate class diagrams with PlantUML. Implement other diagram types (entity, ER, flow, component, usecase, DB schema) - âœ… DONE (All listed diagrams implemented as SVG)
9. Iteration 9: Generate Swagger (OpenAPI via SpringDoc for Spring Boot) or SOAP docs + microservice summary. Extract project name. - âœ… DONE (OpenAPI gen, project name, summary string)
10. Iteration 10: Build full UI with tabs/sidebar (Overview, Endpoints, Diagrams, Call Flow, DB Schema, Classes, Gherkin, Export) using Material UI. - âœ… DONE
11. Iteration 11: Export to Confluence + PDF/HTML downloads - (Future Enhancement)

/*
====================================
ğŸ“˜ README.md BACKEND EXCERPT (Superseded by actual README.md)
====================================
*/

/*
====================================
ğŸ“˜ README.md FRONTEND EXCERPT (Superseded by actual README.md)
====================================
*/

/*
====================================
ğŸ“˜ KEY IMPLEMENTATION UPDATES (Consolidated & Chronological - May 2025)
====================================
**Initial Phase & Foundation:**
- Backend categorizes classes (`type` field: controller, service, etc.). Frontend uses this for filtering.
- Backend serves generated SVG diagrams; Frontend displays them via `DiagramViewer.js`.
- Project name extracted from Git URL.
- Frontend navigation via `Sidebar.js`.
- Basic WSDL/XSD display in `ApiSpecsPage.js`, OpenAPI via SwaggerUI.
- `svg-viewer.html` for standalone SVG viewing.
- CORS enabled for static resources.

**Core Parsing & Analysis Overhaul (Iterative):**

1.  **Symbol Resolution Engine (Backend - `JavaParserServiceImpl`):**
    *   **Integrated JavaSymbolSolver:** Configured with `CombinedTypeSolver` including `ReflectionTypeSolver`, `JavaParserTypeSolver` (for multiple source roots like `src/main/java`, `src/test/java`, `target/generated-sources`), and crucially, `JarTypeSolver` for all project dependencies (via `mvn dependency:build-classpath`).
    *   **Pre-compilation Step:** Added `mvn compile -DskipTests -q` before symbol solving to ensure generated sources (Lombok, JAXB, etc.) are available, dramatically improving resolution accuracy.
    *   **FQN-centric:** Standardized on Fully Qualified Names for class and method identification and storage.
    *   **Lombok Consideration:** `target/classes` included in type solvers to help with Lombok; complex fluent builders/getters might still be partially resolved but get descriptive names.
    *   **Robust Fallbacks for Unresolved Calls:** If a method call cannot be fully resolved, it attempts to:
        *   Determine the scope (class of the object a method is called on).
        *   Resolve argument types.
        *   Provides descriptive unresolved signatures like `UNRESOLVED_CALL: com.example.MyClass.myMethod(java.lang.String, int)` or `UNRESOLVED_CALL: UNRESOLVED_SCOPE.myMethod(...)`.
        *   Specific prefixes for JDK/common library calls (`FRAMEWORK_CALL (JDK/Lib): ...`) and Spring Data methods (`FRAMEWORK_CALL (Spring Data): ...`).
    *   **Accurate Class Type Determination (`determineClassType`):** Refined logic to prioritize JPA annotations (`@Entity`) for "entity" type. Uses package name (from `CompilationUnit`) and stereotype annotations for other types (controller, service, repository, model, etc.).
    *   **Annotation Member Parsing:** Added `FieldMetadata` with an `initializer` field to capture default values in annotation members.

2.  **Call Flow Analysis (Backend - `CallFlowAnalyzer`, `DiagramServiceImpl`):**
    *   Receives method metadata (with resolved/descriptively unresolved call details) from `JavaParserServiceImpl`.
    *   Performs DFS from entry points (e.g., controller methods) to build call sequences.
    *   Stores raw call flow steps.
    *   `DiagramServiceImpl.generateSequenceDiagram` uses these steps to create PlantUML source.
    *   Added helper methods (`getCleanParticipantName`, `getCleanCallLabel`) in `DiagramServiceImpl` to strip prefixes and format names/labels for clearer sequence diagrams.
    *   Handles cases where `methodLookupKey` itself indicates an unresolved/framework call to prevent redundant processing.

3.  **DAO & Database Analysis (Backend - `DaoAnalysisServiceImpl`, `DaoAnalyzer`):**
    *   Identifies Spring Data repository interfaces and methods.
    *   Extracts entity names from repository generics.
    *   Generates synthetic queries for common Spring Data methods.
    *   `DaoAnalyzer` detects basic SQL queries and table names from method bodies using regex.
    *   `generateDbDiagram` in `DaoAnalysisServiceImpl` now uses all known entities (`List<ClassMetadata>`) for a more complete schema diagram.

4.  **Diagram Generation (Backend - `DiagramServiceImpl`, `PlantUMLRenderer`):**
    *   Generates Class, Component, Usecase, Sequence, ERD, and Database Schema diagrams as SVGs.
    *   Component Diagram: Enhanced to identify components via class names, annotations, and Spring stereotypes; determines component roles and semantic relationships; uses package hierarchy for organization.
    *   Usecase Diagram: Extended actor model ("External System" for SOAP); multi-level usecase detection (controller, service, DB operations); specialized SOAP endpoint handling.
    *   Requires Graphviz `dot`.

5.  **Spring Boot Integration (Backend & Frontend):**
    *   `ProjectDetectorServiceImpl` accurately detects Spring Boot projects and their versions.
    *   `ParsedDataResponse` carries `isSpringBootProject` (as `springBootProject` due to Jackson serialization of boolean getter) and `springBootVersion`.
    *   Frontend `Overview.js` correctly displays this information.
    *   Backend `DocumentationServiceImpl.generateProjectSummary` uses these flags for its textual summary.

6.  **Frontend Enhancements:**
    *   **Call Flow Page (`CallFlowPage.js`):** Displays sequence diagram images alongside raw textual call steps, correctly associating them by FQN.
    *   **Database Page (`Database.js`):** Displays schema diagram and lists entities.
    *   **General Diagram Display (`DiagramViewer.tsx`, `Diagrams.js`):** Correctly handles image types and prepends `BACKEND_STATIC_BASE_URL` for diagram URLs.
    *   Sequence diagram titles in `Diagrams.js` are shortened for readability while retaining FQN for keys.

7.  **Logging & Debugging (Backend):**
    *   Implemented dedicated, configurable logger (`com.codedocgen.parser.ClassMetadataVisitorLogger`) for detailed `TRACE` logs in `JavaParserServiceImpl$ClassMetadataVisitor`.
    *   Extensive `DEBUG` and `TRACE` logs added throughout the parsing pipeline.
    *   `application.yml` configured for fine-grained logging control.

8.  **Build & Stability (Backend):**
    *   Resolved numerous compilation errors and runtime `NullPointerExceptions` through iterative debugging and refinement.
    *   Ensured correct handling of `currentMethodMetadata` within `ClassMetadataVisitor` by properly using the visitor pattern for method body traversal.

**Key Challenges Addressed:**
-   Accurate symbol resolution in Java, especially with Lombok, generics, and external libraries.
-   Distinguishing between different types of classes (entity, model, service, etc.).
-   Generating meaningful and accurate sequence diagrams from parsed call data.
-   Ensuring frontend correctly receives and displays all backend-generated data and diagrams.
-   Configuring and verifying detailed logging for deep diagnostics.

**Current Status & Focus (Post-May 2025 Intensive Debugging):**
-   Core parsing and analysis engine is significantly more robust.
-   Call flows and sequence diagrams are largely accurate, with unresolved calls clearly marked.
-   Database schema and entity detection is improved.
-   Focus has shifted from major parsing bugs to refining the detail and presentation of the generated documentation.
-   The system can successfully process complex Spring Boot applications and generate a comprehensive set of diagrams and metadata.
*/

// Note: The "Recent Updates (May 2025)" section below is largely superseded and integrated into the more detailed "KEY IMPLEMENTATION UPDATES" above.
// It can be kept for a historical perspective or removed/archived.

## Recent Updates (May 2025) - Historical Snapshot, see consolidated list above
- Diagrams are now generated and served as SVG for best quality and Confluence publishing.
// ... (rest of the old "Recent Updates" section can be truncated or reviewed for any unique points not covered above)
...
